# Plugin Development Workflow

**Purpose:** Step-by-step process for creating InvenTree plugins from user stories to production  
**Audience:** Plugin developers (human + AI)  
**Approach:** Iterative test-driven development (not waterfall, not pure Scrum)

---

## Philosophy

**Don't:**
- ‚ùå Write all architecture upfront (requirements will change)
- ‚ùå Write all tests upfront (you'll guess wrong)
- ‚ùå Implement all features before deploying (stack unverified changes)

**Do:**
- ‚úÖ Start with user stories and minimal skeleton
- ‚úÖ Implement one feature end-to-end (vertical slice)
- ‚úÖ Write test BEFORE implementing feature (test-first)
- ‚úÖ Deploy and validate after each feature
- ‚úÖ Document as patterns emerge

---

## Phase 1: User Stories & Skeleton (1-2 hours)

### 1.1 Gather User Stories

Write 3-5 stories in format:
```
As a [role], I want to [action] so I can [benefit].
```

**Example:**
```
As a production planner, I want to see total BOM cost so I can estimate project budgets.
As a purchaser, I want to export a parts list with suppliers so I can request quotes.
As an engineer, I want to flag obsolete parts so I can update designs.
```

**Tips:**
- Start with simplest/most valuable story
- Keep scope small for MVP (3-5 stories max)
- Focus on user value, not technical details

### 1.2 Create Plugin Skeleton

```powershell
cd 'C:\PythonProjects\Inventree Plugin Creator\inventree-plugin-ai-toolkit'
.\scripts\New-Plugin.ps1
```

**Answer prompts:**
- Plugin name (PascalCase, no spaces)
- Description (one sentence)
- Author info
- Choose mixins based on user stories:
  - `SettingsMixin` - Plugin needs configuration
  - `UrlsMixin` - Custom API endpoints
  - `UserInterfaceMixin` - UI panels/tabs
  - `EventMixin` - React to InvenTree events
  - `ScheduleMixin` - Background tasks

### 1.3 Write One-Page README

In `plugins/YourPlugin/README.md`, write:

```markdown
# Your Plugin Name

**Purpose:** [One sentence describing what plugin does]

## Features

- [ ] Feature 1 (Story 1)
- [ ] Feature 2 (Story 2)
- [ ] Feature 3 (Story 3)

## Installation

[Standard installation instructions - auto-generated by New-Plugin.ps1]

## Usage

[One paragraph - how user accesses the plugin]

## Configuration

[List plugin settings if any]
```

### 1.4 Sketch Data Flow

Write 5-10 lines showing data flow for primary feature:

```
User clicks "Calculate Cost" button
  ‚Üí Frontend calls /api/plugin/bom-cost/{part_id}/
    ‚Üí Backend: get_flat_bom(part_id)
      ‚Üí For each part: lookup supplier price
        ‚Üí Sum total cost
          ‚Üí Return JSON with cost breakdown
            ‚Üí Frontend displays in table
```

**Don't:**
- ‚ùå Design complete class hierarchy
- ‚ùå Define all API endpoints
- ‚ùå Write detailed algorithms

**Do:**
- ‚úÖ Understand high-level flow
- ‚úÖ Identify unknowns to research
- ‚úÖ Commit skeleton to git

---

## Phase 2: First Vertical Slice (2-4 hours)

### 2.1 Pick Simplest User Story

**Example:** "Show total BOM cost on part page"

### 2.2 Write ONE Test

Create `your_plugin/tests/test_cost_calculation.py`:

```python
from InvenTree.unit_test import InvenTreeTestCase
from part.models import Part, BomItem

class CostCalculationTests(InvenTreeTestCase):
    """Test BOM cost calculation."""
    
    @classmethod
    def setUpTestData(cls):
        """Create minimal test data."""
        super().setUpTestData()
        
        # Parent assembly
        cls.parent = Part.objects.create(
            name="Test Assembly",
            active=True,
            assembly=True
        )
        
        # Child parts with prices
        cls.child1 = Part.objects.create(
            name="Resistor",
            active=True,
            purchaseable=True,
        )
        # Add purchase price here (simplified for example)
        
        cls.child2 = Part.objects.create(
            name="Capacitor",
            active=True,
            purchaseable=True,
        )
        
        # BOM items
        BomItem.objects.create(
            part=cls.parent,
            sub_part=cls.child1,
            quantity=10
        )
        BomItem.objects.create(
            part=cls.parent,
            sub_part=cls.child2,
            quantity=5
        )
    
    def test_simple_two_level_bom_cost(self):
        """Test cost calculation for 2-level BOM."""
        # Arrange - done in setUpTestData
        
        # Act
        from your_plugin.cost_calculator import calculate_bom_cost
        cost = calculate_bom_cost(self.parent.pk)
        
        # Assert
        self.assertEqual(cost, 2.25)  # (10 √ó 0.10) + (5 √ó 0.25)
        self.assertIsInstance(cost, float)
```

**Run test (expect failure):**
```powershell
.\scripts\Test-Plugin.ps1 -Plugin "YourPlugin" -Unit
```

### 2.3 Implement Minimal Code

Create `your_plugin/cost_calculator.py`:

```python
"""BOM cost calculation logic."""
import logging
from part.models import Part, BomItem

logger = logging.getLogger('inventree')

def calculate_bom_cost(part_id):
    """
    Calculate total cost of a BOM.
    
    Args:
        part_id: Part database ID
        
    Returns:
        float: Total BOM cost
    """
    try:
        part = Part.objects.get(pk=part_id)
    except Part.DoesNotExist:
        logger.error(f"Part {part_id} not found")
        return 0.0
    
    if not part.assembly:
        logger.warning(f"Part {part_id} is not an assembly")
        return 0.0
    
    total_cost = 0.0
    bom_items = BomItem.objects.filter(part=part)
    
    for item in bom_items:
        # Simplified - get price from somewhere
        child_cost = get_part_cost(item.sub_part)
        total_cost += child_cost * float(item.quantity)
    
    return total_cost

def get_part_cost(part):
    """Get cost of a single part."""
    # TODO: Implement supplier price lookup
    return 0.0  # Placeholder
```

**Run test again (expect different failure or pass):**
```powershell
.\scripts\Test-Plugin.ps1 -Plugin "YourPlugin" -Unit
```

### 2.4 Add API Endpoint

In `your_plugin/views.py`:

```python
from django.http import JsonResponse
from rest_framework.views import APIView
from .cost_calculator import calculate_bom_cost

class BOMCostView(APIView):
    """API endpoint for BOM cost calculation."""
    
    def get(self, request, part_id):
        """Get total cost for a part's BOM."""
        cost = calculate_bom_cost(part_id)
        
        return JsonResponse({
            'part_id': part_id,
            'total_cost': cost,
            'currency': 'USD'  # TODO: Get from settings
        })
```

In `your_plugin/core.py`:

```python
from plugin import InvenTreePlugin
from plugin.mixins import UrlsMixin, UserInterfaceMixin

class YourPlugin(InvenTreePlugin, UrlsMixin, UserInterfaceMixin):
    # ... existing code ...
    
    def setup_urls(self):
        """Define custom API endpoints."""
        from django.urls import path
        from .views import BOMCostView
        
        return [
            path('cost/<int:part_id>/', BOMCostView.as_view(), name='bom-cost'),
        ]
```

### 2.5 Add Minimal Frontend

In `frontend/src/Panel.tsx`:

```typescript
import { useState } from 'react';
import { Button, Stack, Text } from '@mantine/core';

export default function BOMCostPanel({ context }) {
    const [cost, setCost] = useState<number | null>(null);
    const [loading, setLoading] = useState(false);
    
    const calculateCost = async () => {
        setLoading(true);
        try {
            const response = await context.api.get(
                `/plugin/your-plugin/cost/${context.id}/`
            );
            setCost(response.data.total_cost);
        } catch (error) {
            console.error('Cost calculation failed:', error);
        } finally {
            setLoading(false);
        }
    };
    
    return (
        <Stack>
            <Button onClick={calculateCost} loading={loading}>
                Calculate BOM Cost
            </Button>
            
            {cost !== null && (
                <Text>Total Cost: ${cost.toFixed(2)}</Text>
            )}
        </Stack>
    );
}
```

### 2.6 Deploy & Validate

```powershell
# Build plugin
.\scripts\Build-Plugin.ps1 -Plugin "YourPlugin"

# Deploy to staging
.\scripts\Deploy-Plugin.ps1 -Plugin "YourPlugin" -Server staging
```

**Manual test checklist:**
- [ ] Panel appears on part detail page
- [ ] Button is clickable
- [ ] Cost displays after clicking
- [ ] No errors in browser console (F12)

**If anything fails:** Fix immediately before moving to next story

**Commit:**
```powershell
git add .
git commit -m "feat: add basic BOM cost calculation

- Implement calculate_bom_cost() function
- Add /cost/{part_id}/ API endpoint
- Display cost in part panel
- Test: test_simple_two_level_bom_cost

Story: Show total BOM cost on part page"
```

---

## Phase 3: Iterate on Remaining Stories (repeat for each)

### 3.1 For Each User Story

1. **Write test for new behavior** (5-10 min)
2. **Implement minimal code** (30-60 min)
3. **Run unit tests** (expect pass)
4. **Build and deploy to staging** (5 min)
5. **Manual test in UI** (10 min)
6. **Commit with story reference** (1 min)

### 3.2 After Every 2-3 Stories

**Refactor if needed:**
- 3 similar functions? Extract to utility
- 200-line function? Split it
- Duplicate logic? DRY it up

**Update documentation:**
- README.md - Mark story as complete, add usage examples
- Add inline code comments for complex logic
- Update test count in TEST-PLAN.md (if it exists)

**Check for patterns:**
- If architecture is emerging, create ARCHITECTURE.md
- If tests need strategy, create TEST-PLAN.md
- Don't create docs until patterns are clear

---

## Phase 4: Harden Before Production (after MVP working)

### 4.1 Add Edge Case Tests

Expand test coverage:
- Zero/None/empty input values
- Very large datasets (1000+ items)
- Missing required data
- Invalid input types
- Concurrent requests

### 4.2 Add Error Handling

```python
def calculate_bom_cost(part_id):
    """Calculate total cost of a BOM."""
    try:
        part = Part.objects.get(pk=part_id)
    except Part.DoesNotExist:
        raise ValueError(f"Part {part_id} not found")
    
    if not part.assembly:
        raise ValueError(f"Part {part_id} is not an assembly")
    
    # ... rest of function
```

### 4.3 Write Documentation

**Create these docs (if patterns exist):**
- `ARCHITECTURE.md` - Technical implementation details
- `TEST-PLAN.md` - Testing strategy and execution
- `CHANGELOG.md` - Version history and changes

**Update README.md:**
- Complete feature list
- Usage examples with screenshots
- Configuration options
- Troubleshooting section

### 4.4 Performance Testing

Test with realistic data:
- Large BOMs (1000+ parts)
- Deep nesting (10+ levels)
- Concurrent users

Add performance thresholds:
```python
def test_large_bom_performance(self):
    """Test calculation time for large BOM."""
    import time
    start = time.time()
    calculate_bom_cost(self.large_part.pk)
    duration = time.time() - start
    self.assertLess(duration, 5.0)  # Must complete in < 5 seconds
```

### 4.5 Production Deployment

**Before deploying to production:**
- [ ] All unit tests pass
- [ ] Manual staging test passed
- [ ] README up to date
- [ ] No critical errors in logs
- [ ] Performance acceptable

```powershell
.\scripts\Deploy-Plugin.ps1 -Plugin "YourPlugin" -Server production
```

---

## Standard Documentation Files

### Required Files (always create)

1. **README.md** - User-facing documentation
   - Features, installation, usage, configuration
   - Start: Day 1 (skeleton)
   - Update: After each story

2. **LICENSE** - Legal terms (MIT recommended)
   - Start: Day 1 (auto-created by New-Plugin.ps1)

### Optional Files (create when patterns emerge)

3. **ARCHITECTURE.md** - Technical implementation
   - API endpoints, data structures, algorithms
   - Create: After 3-5 stories when patterns clear
   - See FlatBOMGenerator for example structure

4. **TEST-PLAN.md** - Testing strategy
   - Test execution, coverage gaps, quality checklist
   - Create: When test count > 20 or test strategy needed
   - See FlatBOMGenerator for example structure

5. **CHANGELOG.md** - Version history
   - Create: When releasing versions to users
   - Format: Keep a Changelog standard

6. **CONTRIBUTING.md** - For open-source plugins
   - Create: When accepting external contributions

### Internal Planning Docs (in docs/internal/)

7. **ROADMAP.md** - Future features and priorities
   - Create: When you have 10+ planned improvements
   - Replaces: "REFAC-PANEL-PLAN.md" (confusing name)

8. **TECHNICAL-DEBT.md** - Known issues to fix
   - Create: When you defer refactoring to ship faster
   - Track: What needs fixing, why, and when

9. **DESIGN-DECISIONS.md** - Why you made certain choices
   - Create: For controversial or non-obvious decisions
   - Example: "Why we use serializers instead of manual dicts"

### Research/Investigation Docs (in docs/internal/)

10. **[FEATURE]-RESEARCH.md** - Investigation notes
    - Create: When exploring complex feature
    - Example: "WARNINGS-RESEARCH.md" (how to detect issues)
    - Delete or archive after implementation

---

## File Naming Conventions

**Use standard, universally recognized names:**

### ‚úÖ Good Names (Clear Purpose)
- `README.md` - User documentation
- `ARCHITECTURE.md` - Technical implementation
- `TEST-PLAN.md` - Testing strategy
- `CHANGELOG.md` - Version history
- `CONTRIBUTING.md` - Contribution guidelines
- `ROADMAP.md` - Future plans
- `TECHNICAL-DEBT.md` - Known issues
- `DEPLOYMENT-WORKFLOW.md` - How to deploy safely

### ‚ùå Bad Names (Confusing)
- `REFAC-PANEL-PLAN.md` - What's "REFAC"? What's "PANEL"?
- `REFAC-HISTORY.md` - Use git history or CHANGELOG.md
- `TEST-QUALITY-REVIEW.md` - Too specific, use TEST-PLAN.md section
- `BOM-ERROR-WARNINGS-RESEARCH.md` - Too verbose, use WARNINGS-RESEARCH.md

**Naming Rules:**
1. Use UPPERCASE for top-level docs (README.md, CHANGELOG.md)
2. Use kebab-case for feature docs (warnings-research.md)
3. Be descriptive but concise (3 words max)
4. Use industry-standard names when they exist
5. Avoid abbreviations (REFAC ‚Üí ROADMAP or TECHNICAL-DEBT)

---

## Common Pitfalls to Avoid

### 1. Writing Tests After Implementation
**Problem:** Tests validate what you built, not what should be built  
**Solution:** Write test first, watch it fail, then implement

### 2. Implementing Multiple Stories Before Deploying
**Problem:** Stack unverified changes, hard to debug failures  
**Solution:** Deploy and validate after each story

### 3. Skipping Manual Testing
**Problem:** Unit tests pass but UI is broken  
**Solution:** 10-minute UI smoke test after every deployment

### 4. Creating Docs Upfront
**Problem:** Docs become outdated as requirements change  
**Solution:** Create docs when patterns emerge (after 3-5 stories)

### 5. Perfect Code on First Try
**Problem:** Over-engineering, analysis paralysis  
**Solution:** Ship working code, refactor when it hurts

### 6. Duplicate Logic in Tests
**Problem:** Tests duplicate production code, don't catch real bugs  
**Solution:** Import and call actual functions, don't reimplement

---

## Example Timeline

### New "BOM Cost Calculator" Plugin

**Week 1: Foundation**
- Day 1: User stories + skeleton + README (2 hours)
- Day 2-3: Vertical slice - basic cost calculation (4 hours)
  - Test written ‚úÖ
  - Function implemented ‚úÖ
  - API endpoint added ‚úÖ
  - UI panel created ‚úÖ
  - Deployed to staging ‚úÖ

**Week 2: Feature additions**
- Day 1: Supplier price lookup (Story 2) - 2 hours
- Day 2: Cost breakdown table (Story 3) - 3 hours
- Day 3: Currency conversion (Story 4) - 2 hours
- Day 4: Refactor + create ARCHITECTURE.md - 2 hours

**Week 3: Hardening**
- Day 1: Add 10 edge case tests - 3 hours
- Day 2: Performance testing + optimization - 3 hours
- Day 3: Error handling + logging - 2 hours
- Day 4: Complete documentation - 2 hours
- Day 5: Production deployment üöÄ

**Total effort:** ~25 hours over 3 weeks (part-time)

---

## Integration with Toolkit

**The toolkit supports this workflow:**

### Planning Phase
- `copilot/plugin-creation-prompts.md` - User story templates
- `docs/toolkit/WORKFLOWS.md` - Common patterns

### Development Phase
- `scripts/New-Plugin.ps1` - Create skeleton
- `scripts/Test-Plugin.ps1` - Run tests quickly
- `scripts/Build-Plugin.ps1` - Compile plugin
- `scripts/Deploy-Plugin.ps1` - Deploy to staging/production

### Learning Phase
- `reference/` folder - Example plugins
- FlatBOMGenerator - Case study (what NOT to do)

---

## Key Takeaways

1. **User stories first** - Know what you're building
2. **Vertical slices** - Implement end-to-end, one story at a time
3. **Test-first** - Write test, watch fail, implement, watch pass
4. **Deploy often** - After each story, deploy and validate
5. **Document late** - After patterns emerge, not before
6. **Refactor when it hurts** - Not before, not never, just when needed
7. **Use standard names** - README, ARCHITECTURE, CHANGELOG (not REFAC-PANEL-PLAN)

---

**This is not waterfall** (no big upfront design)  
**This is not pure Scrum** (test-first, not test-last)  
**This is iterative test-driven development** (build ‚Üí test ‚Üí deploy ‚Üí repeat)

---

_Last Updated: December 18, 2025_
